## Factory
[三种工厂模式对比](https://www.cnblogs.com/cxjchen/p/3143633.html)
### Factory method（工厂模式）
#### 意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。
#### 使用场景： 
1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。   
2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。   
3、设计一个连接服务器的框架，需要三个协议，"POP3"、"IMAP"、"HTTP"，可以把这三个作为产品类，共同实现一个接口。
#### 注意事项：作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。
#### 结构图
![Markdown](https://github.com/masterGGG/HeadFirst/blob/master/icon/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.jpg?raw=true)

### Abstract Factory（抽象工厂模式）
#### 简介：创造工厂的工厂
#### 目的：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。
#### 适用场景： 系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。
#### 优点： 当产品族中有多个对象协同工作时，确保系统使用的都是同一个产品族中的对象。
#### 缺点： 产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。
- 
#### 结构图
![抽象工厂](https://github.com/masterGGG/HeadFirst/blob/master/icon/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82.png?raw=true)
#### [参考](https://blog.51cto.com/zero01/2070033)
